#!/usr/bin/env ruby

# NOTE: If the listbox is empty, that could mean that you have not generated
#  ri documentation for this version of ruby. You can do so by doing:
#    rvm docs generate-ri 
#    or 
#    rvm docs generate
#  (This assumes you are using rvm)
#
# WARNING : IF THIS PROGRAM HANGS check the ri command 
# Maybe your version of ri has different options and is going interactive.
# ruby 1.9.3's ri requires a -l option or else if becomes interactive.
# this program tests out a listbox
# This is written in the old style where we start and end ncurses and initiate a 
# getch loop. It gives more control.
# The new style is to use App which does the ncurses setup and teardown, as well
# as manages keys. It also takes care of logger and includes major stuff.
#
#
#  TODO: what about other docs such as rbcurse, highline and others
#  If search fails try ::str
#  Also when ENTER if class has a :: then try adding it straight to that module RubyCurses::Button
#   and not RubyC::Link.Button -- keep trying options till we get something
require 'logger'
require 'rbcurse'
require 'rbcurse/core/widgets/rlist'
require 'rbcurse/core/widgets/rtextview'
require 'rbcurse/core/include/vieditable'

class RubyCurses::List
  # vieditable includes listeditable which
  # does bring in some functions which can crash program like x and X TODO
  # also, f overrides list f mapping. TODO
  include ViEditable
end
def my_help_text
    <<-eos

    =========================================================================
    Basic Usage

    Press <ENTER> on a class name on the first list, to view ri information
    for it on the right.
    
    Tab to right area, and press <ENTER> on a method name, to see its details
    Press / <slash> in any box to search. e.g /String will take you to the
    first occurrence of String. <n> will take you to next.
    
    To go quickly to first class starting with 'S', type <f> followed by <S>.
    Then press <n> to go to next match.

    On the right window, you may press BACKSPACE to go back to earlier pages.
    You may also press Alt-n and Alt-p to cycle through next and previously
    viewed pages.

    Press Alt-C to enter class or method name and see details. If there is 
    no data returned, or options returned you may have to select from a list.
    e.g. entering 'flatten' may return a list of choices to select from.
    Entering 'Str' returns nothing from ri, so you have to select from classes
    starting with 'Str'.

    Press Alt-D to get a popup of visited classes, from which you may select.

    '?' displays all key binding for current object. 'Q' and 'C-q' quit.
    In any popups, try 'C-q' to quit.

    =========================================================================
    Bookmarks

    Access bookmarks using single-quote as in vim followed by a single character. 
    Some have been set such as Array, String, Hash, File. To create a bookmark,
    position cursor over a class in the left list, and press "m". You will be 
    prompted for the character to use as the mark.
    
    =========================================================================
    Buffers

    Ordinary a textview contains only one buffer. However, the one on the right
    is extended for multiple buffers. Pressing ENTER on the left on several 
    rows opens multiple buffers on the right. Use M-n (Alt-N) and M-p to navigate.
    ALternatively, : maps to a menu, so :n and :p may also be used.
    <BACKSPACE> will also go to previous buffer, like a browser.

    =========================================================================
           Press <M-n> for next help screen, or try :n 

    eos
end

##
#  display the ridoc for given word (class or method or part)
def display_text word
  w = @form.by_name["tv"]; 
  lines = `ri -f rdoc #{word}`.split("\n")
  return if lines.nil? || lines.size == 0
  # ansi can have overflow
  #w.add_content(lines, :content_type => :ansi, :title => word)
  $visited << word unless $visited.index(word)
  w.add_content(lines, :title => word)
  w.buffer_last
end

## 
# prompt user for a class name and show ri doc for same, can be method too
#
def ask_classes
  format="rdoc"
  str = get_string_with_history("Enter a class name: ")
  if str && str != ""
    lines = `ri -f #{format} #{str}`.split("\n")
    if lines.size == 0
      alert "Nothing came through for #{str}"
      ## Nothing returned, lets see if we can match something from the class list
      li = @form.by_name["mylist"]; 
      values = li.list
      values = values.grep(/^#{str}/i)
      if values.size > 0
        ix = popuplist(values)
        if ix
          str = values[ix]
          lines = `ri -f #{format} #{str}`.split("\n")
        end
      else
        alert "Nothing came through for #{str}"
        $message.value = "Nothing came through for #{str}"
      end
    elsif lines.first.index(".#{str} not found")
      ## we are returned something with some choices, lets prompt user with choices
      lines.shift
      lines.shift
        ix = popuplist(lines)
        if ix
          str = lines[ix]
          lines = `ri -f #{format} #{str}`.split("\n")
        end
    end
    return if lines.size == 0
    w = @form.by_name["tv"]; 
    #w.add_content(lines, :content_type => :ansi, :title => str)
    w.add_content(lines, :title => str)
    w.buffer_last
    set_focus_on str
  end
end

# set focus in list on given string
def set_focus_on str
  listb = @form.by_name["mylist"]; 
  ix = listb.list.index(str)
  if ix
    listb.set_focus_on ix
  end
end

## user has pressed bokmark char, now get the mark A-Z
def ask_bookmark
  ch = @window.getchar
  ch = ch.chr.upcase
  str = $bookmarks[ch.to_sym]
  if str
    display_text str
    # set focus to that in the left list
    set_focus_on str
  else
    $message.value = "No bookmark for #{ch}. Use m to create."
    ## No bookmark, jumping to first char 
    listb = @form.by_name["mylist"]; 
    listb.set_selection_for_char ch
  end
end
def add_bookmark ch, word
  $bookmarks[ch.upcase.to_sym] = word
  alert "set mark for #{ch.upcase.to_sym} for #{word}"
end

## try various options till you get something.
#
def try_ri arr
  _text = nil
  arr.each do |w|
    _text = `ri -f rdoc #{w} 2>&1`.split("\n")
    if _text.first.index("Nothing known about")
    else
      break
    end
  end
  _text
end
def popup_history
  return if $visited.size == 0
  ix = popuplist($visited, :title => " History ", :bgcolor => :blue, :color => :white)
  if ix
    display_text $visited[ix]
  end
end
def get_string_with_history prompt
  $shell_history ||= []
  cmd = get_string(prompt, :maxlen => 50) do |f|
    require 'rbcurse/core/include/rhistory'
    f.extend(FieldHistory)
    f.history($shell_history)
  end
  if cmd && !cmd.empty?
    $shell_history.push(cmd) unless $shell_history.include? cmd
  end
  return cmd
end



#if $0 == __FILE__
if true
  include RubyCurses

  begin
    # Initialize curses
    VER::start_ncurses  # this is initializing colors via ColorMap.setup
    logfilename = File.join(ENV["LOGDIR"] || "./" ,"rbc13.log")
    $log = Logger.new(logfilename)
    $log.level = Logger::DEBUG

    $visited = []
    $bookmarks = {
      :A => "Array",
      :C => "Class",
      :D => "Dir",
      :F => "File",
      :H => "Hash",
      :I => "IO",
      :K => "Kernel",
      :S => "String"
    }
    config = File.expand_path("~/.ribhu.conf")
    # read up any bookmarks or visited classes, they get added to the existing data
    if File.exists? config
      load config
    end


    @window = VER::Window.root_window
    $catch_alt_digits = true; # emacs like alt-1..9 numeric arguments
    install_help_text my_help_text
    # Initialize few color pairs 
    # Create the window to be associated with the form 
    # Un post form and free the memory

    catch(:close) do
      @form = Form.new @window
      @form.bind_key(KEY_F1, 'help'){ display_app_help }
      @form.bind_key(?\M-c, 'select class') do
        ask_classes
      end
      @form.bind_key(?', 'select bookmark') do
        ask_bookmark
      end
      @form.bind_key(?\M-d, 'View history') do
        popup_history
      end

      header = app_header "0.0.2", :text_center => "ri Documentation Browser", :text_right =>"" #, :color => :black, :bgcolor => :white #, :attr => :bold 
      # this is the old style of printing something directly on the window.
      # The new style is to use a header
      #@form.window.printstring 0, 30, "ri documentation browser", $normalcolor, BOLD
      r = 1; fc = 1;

      # this is the old style of using a label at the screen bottom, you can use the status_line

      v = "Q quit, F1 Help, ? Bindings,  f<char>, /,  Alt-c, ENTER on Class or Method"
      #var = RubyCurses::Label.new @form, { :text => v, :row => FFI::NCurses.LINES-2, 
        #:col => fc, :display_length => 100}
      $message = Variable.new
      $message.value = "Message Comes Here"
      @status_line = status_line :row => Ncurses.LINES-1
      @status_line.command {
        "F1 Help | Q Quit | ? Keys | M-c Classes | M-d History | %20s" % [$message.value]
      }

      h = FFI::NCurses.LINES-2
      mylist = `ri -l `.split("\n")
      w = 25

      listb = List.new @form, :name   => "mylist" ,
        :row  => r ,
        :col  => 1 ,
        :width => w,
        :height => h,
        :list => mylist,
        :selection_mode => :SINGLE,
        :show_selector => true,
        :title => " Ruby Classes "
      #title_attrib 'reverse'
      listb.one_key_selection = false # this allows us to map keys to methods
      #listb.vieditable_init_listbox
      # what for is Io here
      include Io
      listb.bind_key(32) {|l| l.scroll_forward };
      listb.bind(:PRESS) { 
        display_text listb.text
        ## select class and display riinfo for class
      }
      listb.bind_key(?m) { 
        str = listb.text
        ch = get_string("Enter character as shortcut for #{str}")
        if ch && ch != ""
          add_bookmark ch[0], str
        end
        ## select class and display riinfo for class
      }
      #listb.unbind_key([?', ?'])
      #listb.unbind_key(["'","'"])
      #listb.unbind_key("'")
      listb.bind_key(?', 'select bookmark') do
        ask_bookmark
      end

      tv = RubyCurses::TextView.new @form, :row => r, :col => w+1, :height => h, :width => FFI::NCurses.COLS-w-1,
        :name => "tv", :title => "Press Enter on method"
      tv.set_content ["Press Enter on list to view ri information in this area.", 
        "Press ENTER on method name to see details"]
      require 'rbcurse/core/include/multibuffer'
      tv.extend(RubyCurses::MultiBuffers)
      #tv.unbind_key([?', ?'])
      #tv.unbind_key(?')
      tv.bind_key(?', 'select bookmark') do
        ask_bookmark
      end

      # pressing ENTER on a method name will popup details for that method
      tv.bind(:PRESS) { |ev|
        w = ev.word_under_cursor.strip
        # check that user did not hit enter on empty area
        if w != ""
          #alert "wuc:#{w}:cp=#{ev.curpos},"
          #if w.index("::")
          #str=w
          #else
          str = "#{tv.title}.#{w}"
          _text = try_ri(["#{str}", w])
          #end
          tt = tv.title
          #_text = `ri -f rdoc #{str} 2>&1` 
          #_text = _text.split("\n")
          if _text.first.index("Nothing known about")
            $log.debug "XXXX got #{_text}"
            if tt.index("::")
              ix = tt.index("::")
              tt = tt[0,ix]
              _text = `ri -f rdoc #{tt}::#{w} 2>&1`.split("\n")
            end
          end
          if _text && _text.size != 0
            #view(_text, :content_type => :ansi)
            view(_text)
          end
        end
      }
      tv.bind_key(?\M-m, "Select methods") {
        kl = tv.title.strip
        lines = tv.text
        ix = lines.index("= Instance methods:")
        unless ix
          alert "No instance methods found"
        end
        if ix
          values = lines[ix+2..-1]
          values = values.collect { |x| x.strip }
          #ix = popuplist(values)
          ix = popuplist(values, :title => " Methods ", :bgcolor => :blue, :color => :white)
          if ix
            meth = values[ix].strip
            display_text "#{kl}.#{meth}"
          end
        end
      }


      @form.repaint
      @window.wrefresh
      Ncurses::Panel.update_panels
      while((ch = @window.getchar()) != KEY_F10 )
        break if ch == ?Q.ord || ch == ?\C-q.getbyte(0)
        @form.handle_key(ch)
        @window.wrefresh
      end
    end
  rescue => ex
    textdialog ["Error in rib: #{ex} ", *ex.backtrace], :title => "Exception"
    $log.debug( ex) if ex
    $log.debug(ex.backtrace.join("\n")) if ex
  ensure
    @window.destroy if !@window.nil?
    VER::stop_ncurses
    p ex if ex
    p(ex.backtrace.join("\n")) if ex
  end
  else
    puts "Error #{$0}, #{__FILE__}"
end
